(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{208:function(e,n){e.exports={attributes:{title:"Unit Testing Guide in Vue.js",slug:"unit-testing-guide-in-vuejs",date:"2019-03-19",minute2read:20,description:"Steps to install and test the code Vue.js and Nuxt.js by learning from various cases that occur in real world projects",categories:["javascript","testing"],cover:"https://www.mazipan.xyz/content-images/unit-testing-guide-in-vuejs/commitstrip.jpg"},html:"<h2 id=\"navigasi\">Navigasi</h2>\n<ul>\n<li><a href=\"#Mengenai-Unit-Testing\">Mengenai Unit Testing</a></li>\n<li><a href=\"#Prinsip-Utama\">Prinsip Utama</a></li>\n<li><a href=\"#Beberapa-Siklus-Hidup-Umum-di-Unit-Test\">Beberapa Siklus Hidup Umum di Unit Test</a></li>\n<li><a href=\"#Memasang-Unit-Testing-di-Vue-dan-Nuxt\">Memasang Unit Testing di Vue dan Nuxt</a>\n<ul>\n<li><a href=\"#Memasang-Jest-menggunakan-Vue-CLI-3\">Memasang Jest menggunakan Vue-CLI 3</a></li>\n<li><a href=\"#Memasang-Jest-tanpa-Vue-CLI\">Memasang Jest tanpa Vue-CLI</a></li>\n<li><a href=\"#Memasang-Jest-pada-Nuxt-dengan-create-nuxt-app\">Memasang Jest pada Nuxt dengan create-nuxt-app</a></li>\n<li><a href=\"#Memasang-Jest-pada-Nuxt-secara-manual\">Memasang Jest pada Nuxt secara manual</a></li>\n</ul>\n</li>\n<li><a href=\"#Perbedaan-Dasar-Soal-Nuxt-dengan-Vue\">Perbedaan Dasar Soal Nuxt dengan Vue</a></li>\n<li><a href=\"#Testing-JavaScript-File-Sederhana\">Testing JavaScript File Sederhana</a></li>\n<li><a href=\"#Testing-Mounting-Komponen-Vue\">Testing Mounting Komponen Vue</a></li>\n<li><a href=\"#Testing-Method-di-Komponen-Vue\">Testing Method di Komponen Vue</a></li>\n<li><a href=\"#Mensimulasikan-Aksi-Klik-Elemen\">Mensimulasikan Aksi Klik Elemen</a></li>\n<li><a href=\"#Testing-Props-di-Komponen-Vue\">Testing Props di Komponen Vue</a></li>\n<li><a href=\"#Testing-Computed-dan-Watcher\">Testing Computed dan Watcher</a></li>\n<li><a href=\"#Testing-Event-Emitter\">Testing Event Emitter</a></li>\n<li><a href=\"#Testing-Perpindahan-Route\">Testing Route</a>\n<ul>\n<li><a href=\"#Testing-Perpindahan-Route\">Testing Perpindahan Route</a></li>\n<li><a href=\"#Testing-Mounting-Route\">Testing Mounting Route</a></li>\n</ul>\n</li>\n<li><a href=\"#Testing-Vuex\">Testing Vuex</a>\n<ul>\n<li><a href=\"#Testing-Getters\">Testing Getters</a></li>\n<li><a href=\"#Testing-Mutations\">Testing Mutations</a></li>\n<li><a href=\"#Testing-Actions\">Testing Actions</a></li>\n<li><a href=\"#Testing-Vuex-di-Komponen\">Testing Vuex di Komponen</a></li>\n<li><a href=\"#Testing-Vuex-dengan-Modules\">Testing Vuex dengan Modules</a></li>\n</ul>\n</li>\n<li><a href=\"#Testing-dengan-Vue-i18n\">Testing dengan Vue-i18n</a></li>\n<li><a href=\"#Testing-Pemanggilan-Rest-API\">Testing Pemanggilan Rest API</a></li>\n</ul>\n<h2 id=\"Mengenai-Unit-Testing\">Mengenai Unit Testing</h2>\n<p>Unit testing (UT) merupakan bagian terkecil dari proses pengetesan sebuah aplikasi perangkat lunak. UT berfokus untuk mengetest bagian terkecil sebuah aplikasi yakni potongan-potongan kode yang dibuat oleh pengembangnya, itu mengapa UT paling ideal dibuat oleh pengembang itu sendiri. Dengan mengetest kode-kode kecil di dalam sebuah aplikasi diharapkan kita bisa menghasilkan aplikasi perangkat lunak dengan kualitas yang lebih bisa dijamin.</p>\n<img v-lazyload src=\"/images/placeholder-1x1.png\" data-src=\"/content-images/unit-testing-guide-in-vuejs/commitstrip.jpg\" alt=\"Unit Test Meme by commitstrip\" height=\"200px\" width=\"200px\">\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Prinsip-Utama\">Prinsip Utama</h2>\n<p>Ada beberapa prinsip utama dalam melakukan unit testing, beberapa diantaranya yang dikenal dengan <strong>FIRST</strong></p>\n<ol>\n<li><strong>F - Fast</strong> (Cepat), unit test harus bisa dieksekusi dengan cepat, tidak memakan waktu yang lebih lama dibandingkan ketika harus menjalankan aplikasi secara utuh untuk melakukan test manual.</li>\n<li><strong>I - Isolated</strong> (Dapat Diisolasi), unit test harus bisa diisolasi antar satu dengan yang lain, ketika terjadi kegagalan maka harus bisa dipastikan tidak merembet ke berkas testing pada bagian lain.</li>\n<li><strong>R - Repeatable</strong> (Dapat Diulang), unit testing harus bisa dijalankan kapan saja dan menghasilkan hasil yang sama. Tidak terikat pada hari tertentu, waktu tertentu atau zona waktu tertentu.</li>\n<li><strong>S - Self-Validating</strong> (Validasi Diri Sendiri), setiap test harus bisa menentukan sendiri apakah gagal atau berhasil menjalankan test tanpa perlu dilakukan verifikasi secara manual.</li>\n<li><strong>T - Timely</strong> (Tepat Waktu), test ditulis pada waktu yang tepat segera setelah kodenya selesai dibuat atau dalam praktik TDD, test dibuat terlebih dahulu untuk bisa memberi arahan yang lebih baik pada saat menulis kode.</li>\n</ol>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Beberapa-Siklus-Hidup-Umum-di-Unit-Test\">Beberapa Siklus Hidup Umum di Unit Test</h2>\n<ol>\n<li><strong>Setup</strong> adalah siklus dimana kita menyiapkan berbagai kebutuhan skenario test yang akan dijalankan, di Jest mungkin kita akan menggunakan sintaksis seperti <code>BeforeAll</code> atau <code>BeforeEach</code> untuk melakukan setup sebelum skenario test dijalankan.</li>\n<li><strong>Test Execution</strong> adalah siklus dimana test dijalankan dengan segala setup yang telah didefinisikan sebelumnya. Di Jest kita bisa menggunakan <code>test()</code> atau <code>it()</code> untuk mendefinisikan masing-masing skenario dan bisa dikelompokkan ke dalam satu grup menggunakan <code>describe()</code>.</li>\n<li><strong>Teardown</strong> adalah siklus dimana unit test selesai dijalankan, pada tahap ini biasanya dilakukan pembersihan dari segala macam hal yang mungkin akan mengganggu proses test selanjutnya. Hal ini dikarenakan seringkali kita akan melakukan berbagai macam trik seperti <em>mock</em>, <em>spy</em>, dan lainnya yang kalau tidak dibersihkan dikhawatirkan akan mengganggu ketika skenario selanjutnya dijalankan. Di Jest kita bisa menggunakan kait <code>afterEach</code> maupun <code>afterAll</code>.</li>\n</ol>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Memasang-Unit-Testing-di-Vue-dan-Nuxt\">Memasang Unit Testing di Vue dan Nuxt</h2>\n<p>Saya akan spesifik membahas bagaimana cara memasang Unit Test pada <em>framework</em> <a href=\"https://jestjs.io/en/\">Jest â†—ï¸</a> beberapa kode yang akan saya sertakan pun akan spesifik pada Jest, bila Anda menggunakan <em>framework</em> lain, bisa melihat pada referensi yang akan saya sertakan berikut:</p>\n<ul>\n<li><a href=\"https://vue-test-utils.vuejs.org/guides/testing-single-file-components-with-mocha-webpack.html\">Memasang unit test pada Mocha + Webpack â†—ï¸</a></li>\n<li><a href=\"https://vue-test-utils.vuejs.org/guides/testing-single-file-components-with-karma.html\">Memasang unit test pada Karma â†—ï¸</a></li>\n</ul>\n<p>Untuk Jest sendiri berikut cara memasang Unit Test pada beberapa projek:</p>\n<h3 id=\"Memasang-Jest-menggunakan-Vue-CLI-3\">Memasang Jest menggunakan Vue-CLI 3</h3>\n<ul>\n<li>Pasang Vue-CLI 3 dengan perintah</li>\n</ul>\n<pre><code class=\"language-bash\">$ yarn add @vue/cli\n#atau\n$ npm i -g @vue/cli\n</code></pre>\n<ul>\n<li>\n<p>Buat projek baru dengan <code>vue create my-project-name</code>. Pilih <em>&quot;Manually select features&quot;</em> dan centang &quot;Unit Testing&quot; dan &quot;Jest&quot; untuk runner unit testnya, silakan lihat artikel resmi <a href=\"https://cli.vuejs.org/guide/creating-a-project.html\">membuat project baru dengan Vue-CLI â†—ï¸</a> untuk lebih jelasnya.</p>\n</li>\n<li>\n<p>Jalankan unit test dengan perintah <code>yarn test:unit</code> dan semua konfigurasi sudah dibuatkan oleh Vue-CLI tanpa kita harus melakukan secara manual.</p>\n</li>\n</ul>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h3 id=\"Memasang-Jest-tanpa-Vue-CLI\">Memasang Jest tanpa Vue-CLI</h3>\n<p>Pasang beberapa dependency untuk menjalankan unit test dengan jest berikut:</p>\n<pre><code class=\"language-bash\">$ yarn add jest babel-jest vue-jest @vue/test-utils -D\n# atau\n$ npm i jest babel-jest vue-jest @vue/test-utils --dev\n</code></pre>\n<p>Perintah tersebut akan menambahkan dependency berikut pada projek kita:</p>\n<ul>\n<li><code>jest</code></li>\n<li><code>babel-jest</code></li>\n<li><code>vue-jest</code></li>\n<li><code>@vue/test-utils</code></li>\n</ul>\n<p>Buat file konfigurasi untuk Jest dengan nama file <code>jest.config.js</code> dengan isi konfigurasi sebagai berikut:</p>\n<pre><code class=\"language-javascript\">module.exports = {\n  moduleNameMapper: {\n    '^~/(.*)$': '&lt;rootDir&gt;/$1',\n    '^@/(.*)$': '&lt;rootDir&gt;/$1',\n    '^vue$': 'vue/dist/vue.common.js'\n  },\n  moduleFileExtensions: ['js', 'vue', 'json'],\n  transform: {\n    '^.+.js$': '&lt;rootDir&gt;/node_modules/babel-jest',\n    '^.+.vue$': '&lt;rootDir&gt;/node_modules/vue-jest'\n  }\n}\n</code></pre>\n<p>Pada konfigurasi diatas, beberapa yang perlu kalian ketahui  seperti <code>moduleNameMapper</code> merupakan <code>alias</code> dari direktori kita seperti yang biasa kita lakukan di <code>webpack</code>. Sementara <code>transform</code> digunakan untuk men-transpile kode sebelum diproses oleh Jest, kita gunakan <code>babel-jest</code> dan <code>vue-jest</code> untuk membaca komponen berkas tunggal (<em>single file component</em> - <strong>SFC</strong>) pada Vue.</p>\n<p>Karena kita menggunakan <code>babel</code> juga pada unit test kita, maka jika belum ada konfigurasi babel pada projek kita, silakan tambahkan konfigurasi berikut:</p>\n<pre><code class=\"language-javascript\">// babel.config.js\nmodule.exports = {\n  presets: [\n    [\n      '@vue/app'\n    ],\n  ],\n};\n</code></pre>\n<p>Selanjutnya kita bisa memasang kode tambahan pada <code>package.json</code> kita seperti berikut:</p>\n<pre><code class=\"language-javascript\">{\n  &quot;scripts&quot;: {\n    &quot;test:unit&quot;: &quot;jest&quot;\n  }\n}\n</code></pre>\n<p>Secara bawaan, Jest akan menganggap semua berkas yang berekstensi <code>.spec.js</code> atau <code>.test.js</code> sebagai berkas unit test yang akan dijalankan pada saat perintah <code>jest</code> diketikkan.</p>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h3 id=\"Memasang-Jest-pada-Nuxt-dengan-create-nuxt-app\">Memasang Jest pada Nuxt dengan create-nuxt-app</h3>\n<p>Untuk memasang Jest pada Nuxt, bisa melalui <code>create-nuxt-app</code> yang bisa dilakukan dengan perintah:</p>\n<pre><code class=\"language-bash\">$ yarn create nuxt-app my-project-name\n# atau\n$ npm init nuxt-app my-project-name\n# atau\n$ npx create-nuxt-app my-project-name\n</code></pre>\n<p>Pada pilihan &quot;Choose your favorite test framework:&quot;, silakan pilih &quot;Jest&quot; sebagai unit test yang akan digunakan.</p>\n<p>Jalankan unit test dengan perintah <code>yarn test</code>.</p>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h3 id=\"Memasang-Jest-pada-Nuxt-secara-manual\">Memasang Jest pada Nuxt secara manual</h3>\n<p>Hampir tidak ada perbedaan dengan bagian <a href=\"#Memasang-Jest-tanpa-Vue-CLI\">Memasang Jest tanpa Vue-CLI â†—ï¸</a> pada projek Vue biasa tanpa Nuxt. Perbedaan mungkin hanya ada pada konfigurasi <code>babel</code>, karena pada Vue-CLI kita memanfaatkan babel presets dari Vue yang telah terpasang pada saat membuat projek Vue.</p>\n<p>Kita cukup melakukan konfigurasi babel untuk environment &quot;test&quot; karena projek Nuxt sudah memiliki konfigurasi babel bawaan, seperti berikut contohnya:</p>\n<pre><code class=\"language-javascript\">{\n  &quot;env&quot;: {\n    &quot;test&quot;: {\n      &quot;presets&quot;: [\n        [&quot;@babel/preset-env&quot;, {\n          &quot;targets&quot;: {\n            &quot;node&quot;: &quot;current&quot;\n          }\n        }]\n      ]\n    }\n  }\n}\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Perbedaan-Dasar-Soal-Nuxt-dengan-Vue\">Perbedaan Dasar Soal Nuxt dengan Vue</h2>\n<p>Pada saat ingin membuat unit test untuk projek Nuxt dengan Vue ada beberapa perbedaan yang mesti kalian tau sebelumnya. Seperti kita tau bahwa Nuxt dibangun diatas Vue namun dengan banyak fitur bawaan yang mungkin saja tidak akan kalian temui pada projek Vue yang tanpa Nuxt. Beberapa perbedaan adalah Nuxt punya beberapa tag spesial yang mirip dengan Vue namun tidak akan kalian temui disana, seperti beberapa tag berikut:</p>\n<pre><code class=\"language-html\">&lt;nuxt&gt;&lt;/nuxt&gt;\n&lt;nuxt-child&gt;&lt;/nuxt-child&gt;\n&lt;nuxt-link&gt;&lt;/nuxt-link&gt;\n&lt;no-ssr&gt;&lt;/no-ssr&gt;\n</code></pre>\n<p>Selain itu Nuxt memiliki beberapa properti pada <strong>SFC</strong>-nya seperti berikut diantaranya:</p>\n<pre><code class=\"language-javascript\">export default {\n  head () { },\n  asyncData () { },\n  fetch () { },\n  nuxtServerInit () { },\n  validate () { },\n}\n</code></pre>\n<p>Projek Nuxt tidak memiliki <code>router.js</code> seperti yang biasanya kita buat di projek Vue, Nuxt akan menggunakan struktur folder untuk men-<em>generate</em> berkas router.js untuk projek kita yang letaknya ada di direktori <code>.nuxt</code>.</p>\n<p>Beberapa projek Nuxt juga tidak melakukan <em>instance</em> secara manual terhadap storenya, seperti biasa kita lakukan dengan kode seperti ini misalnya:</p>\n<pre><code class=\"language-javascript\">import Vuex from 'vuex'\n\nconst createStore = () =&gt; {\n  return new Vuex.Store({\n    state: () =&gt; ({\n      counter: 0\n    }),\n    mutations: {\n      increment (state) {\n        state.counter++\n      }\n    }\n  })\n}\n\nexport default createStore\n</code></pre>\n<p>Dengan mengetahui beberapa perbedaan mendasar ini, nantinya akan berguna ketika kita menemui galat yang sebelumnya tidak kita temui pada projek Vue namun ternyata kita temui pada projek Nuxt.</p>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-JavaScript-File-Sederhana\">Testing JavaScript File Sederhana</h2>\n<p>Untuk mengetes berkas JavaScript biasa tentu lebih mudah dibandingkan untuk melakukan test pada file <strong>SFC</strong> Vue. Misalnya saja kita punya berkas <code>helper</code> dengan nama berkas <code>math-util.js</code>, di dalamnya terdapat kode seperti berikut:</p>\n<pre><code class=\"language-javascript\">export function add (a, b) {\n  return a + b\n}\n\nexport function min (a, b) {\n  return a - b\n}\n\nexport function increment (a) {\n  return add(a, 1)\n}\n\nexport function decrement (a) {\n  return min(a, 1)\n}\n</code></pre>\n<p>Maka kita bisa membuatkan berkas untuk unit test dengan nama <code>math-util.spec.js</code> seperti berikut contohnya:</p>\n<pre><code class=\"language-javascript\">import { add, min, increment, decrement } from '@/helpers/math-util'\n\ndescribe('math-util.js', () =&gt; {\n  it('`add` harus mengembalikan nilai yang benar', () =&gt; {\n    expect(add(1, 2)).toBe(3)\n    expect(add(2, 2)).toBe(4)\n    expect(add(2, 3)).toBe(5)\n    expect(add(3, 4)).toBe(7)\n  })\n\n  it('`min` harus mengembalikan nilai yang benar', () =&gt; {\n    expect(min(7, 1)).toBe(6)\n    expect(min(5, 2)).toBe(3)\n    expect(min(4, 3)).toBe(1)\n    expect(min(3, 1)).toBe(2)\n  })\n\n  it('`increment` harus mengembalikan nilai yang benar', () =&gt; {\n    expect(increment(1)).toBe(2)\n    expect(increment(5)).toBe(6)\n    expect(increment(4)).toBe(5)\n    expect(increment(8)).toBe(9)\n  })\n\n  it('`decrement` harus mengembalikan nilai yang benar', () =&gt; {\n    expect(decrement(2)).toBe(1)\n    expect(decrement(5)).toBe(4)\n    expect(decrement(4)).toBe(3)\n    expect(decrement(8)).toBe(7)\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Mounting-Komponen-Vue\">Testing Mounting Komponen Vue</h2>\n<p>Dalam melakukan unit testing pada <strong>SFC</strong>, hal pertama yang harus kita lakukan adalah memastikan kita berhasil memasang atau <em>mounting</em> komponen tersebut ke dalam Virtual DOM yang ada di unit test. Terdengar mudah memang, tapi seringkali justru ini menjadi hal yang tersulit untuk dikerjakan karena setelah berhasil melakukan bagian ini biasanya bagian selanjutnya akan terasa lebih mudah. Untuk bisa melakukan <em>mounting</em> kita diharuskan menyiapkan semua kebutuhan awal sebuah komponen tersebut agar bisa di-<em>mounting</em>. Cara paling bar-bar yang biasa saya lakukan adalah dengan mencoba sampai menemukan galat dan mencoba lagi sampai berhasil, tapi bila kita telah terbiasa nanti kita bisa lebih mendeteksi lebih awal kebutuhan apa saja yang harus kita siapkan untuk <em>mounting</em> komponen tersebut.</p>\n<p>Saya beri contoh misalkan ada komponen dengan templat seperti berikut:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  Hello world, {{ message }}\n&lt;/template&gt;\n</code></pre>\n<p>Dari templat tersebut, kita mesti mencari tau darimana datangnya nilai <code>{{ message }}</code> karena ini dibutuhkan pada saat pertama kali komponen tersebut nantinya dipasang. Bila datang dari <code>data ()</code> bisa jadi aman karena data akan otomatis terbuat ketika komponen dipasang, bila datang dari <em>props</em> berarti kita perlu mengoper <em>props</em> tersebut juga pada unit test kita.</p>\n<p>Untuk contoh yang akan kita gunakan dalam melakukan <em>mounting</em> komponen di unit test akan mengikuti dari contoh yang dibuat oleh tim Vue melalui Vue-CLI yang dibuatkan pada saat awal kita membuat projek baru, berikut contoh melakukan <em>mounting</em> komponen di unit test:</p>\n<p>katakanlah kita mempunyai berkas dengan nama <code>HelloWorld.vue</code> yang berisi templat berikut:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;h1&gt;{{ msg }}&lt;/h1&gt;\n    &lt;!-- banyak kode lain yang kita hilangkan karena dianggap tidak diperlukan --&gt;\n&lt;/template&gt;\n</code></pre>\n<p>Dengan bagian <code>script</code> berisi kode berikut:</p>\n<pre><code class=\"language-javascript\">export default {\n  name: 'HelloWorld',\n  props: {\n    msg: String\n  }\n}\n</code></pre>\n<p>Maka pada berkas <code>hello-world.spec.js</code> kita bisa membuat unit test sebagai berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('renders props.msg ketika dilempar', () =&gt; {\n    const msg = 'new message'\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    })\n    expect(wrapper.text()).toMatch(msg)\n  })\n})\n</code></pre>\n<p>Dari kode diatas kita belajar dasar-dasar memasang komponen pada unit test menggunakan <code>@vue/test-utils</code>, kita menggunakan API <code>shallowMount</code> dibandingkan <code>mount</code> karena kemampuan untuk memalsukan komponen anak sehingga kita tidak perlu mendefinisikan kebutuhan dari komponen anak dari komponen tersebut dan cukup fokus untuk mendefinisikan kebutuhan komponen terkait saja. Hal ini tentu selaras dengan prinsip <em>isolated</em> pada unit testing. Pada contoh diatas kita menambahkan opsi <code>propsData</code> untuk mengoper <em>props</em> yang nanti akan kita bahas di bagian terpisah dibawah nanti.</p>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Method-di-Komponen-Vue\">Testing Method di Komponen Vue</h2>\n<p>Setelah sebelumnya kita berhasil melakukan <em>mounting</em>, maka tugas berikutnya akan lebih mudah seperti yang sudah kita bahas sebelumnya. Pada bagian sebelumnya kita hanya melakukan <em>mounting</em> komponen tanpa memanggil <em>method</em> apapun, berikut contoh memanggil <em>method</em> dalam Vue <strong>SFC</strong> melalui unit test:</p>\n<p>Menggunkan berkas sebelumnya, kita akan menambahkan <em>method</em> pada <strong>SFC</strong>-nya dan melakukan sedikit perubahan seperti berikut:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;h1&gt;{{ msg }}&lt;/h1&gt;\n&lt;/template&gt;\n</code></pre>\n<p>Dengan bagian <code>script</code> berisi kode berikut:</p>\n<pre><code class=\"language-javascript\">export default {\n  name: 'HelloWorld',\n  data () {\n    return {\n      msg: 'Sebuah pesan'\n    }\n  },\n  methods: {\n    changeMessage (newMessage) {\n      this.msg = newMessage\n    }\n  }\n}\n</code></pre>\n<p>Dari kode diatas, kita bisa membuatkan unit test seperti berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('berhasil mounting komponen', () =&gt; {\n    const msgExpected = 'Sebuah pesan'\n    const wrapper = shallowMount(HelloWorld)\n    expect(wrapper.vm.msg).toBe(msgExpected)\n  })\n\n  it('berhasil memanggil changeMessage', () =&gt; {\n    const msgExpected = 'Sebuah pesan'\n    const msgAfterChangeExpected = 'Sebuah pesan baru'\n    const wrapper = shallowMount(HelloWorld)\n    expect(wrapper.vm.msg).toBe(msgExpected)\n    // memanggil method changeMessage\n    wrapper.vm.changeMessage(msgAfterChangeExpected)\n    expect(wrapper.vm.msg).toBe(msgExpected)\n  })\n})\n</code></pre>\n<p>Dari kode unit test diatas kita bisa mengetahui bahwa kita bisa langsung mengakses berbagai fitur Vue komponen lewat <code>wrapper.vm</code>, ini sama saja seperti <code>this</code> pada <strong>SFC</strong> yang merujuk pada <em>instance</em> dari komponen tersebut. Kita bisa mengakses <em>data</em>, <code>method</code>, <em>props</em>, hasil dari <em>computed</em> dan lainnya menggunakan <code>wrapper.vm</code> yang merupakan fitur <code>@vue/test-utils</code>.</p>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Mensimulasikan-Aksi-Klik-Elemen\">Mensimulasikan Aksi Klik Elemen</h2>\n<p>Beberapa programmer tidak senang melakukan akses langsung ke <em>method</em> tanpa melalui akses ke tampilan pengguna. Seperti pada contoh sebelumnya, unit test tersebut menjadi tidak masuk akal karena method <code>changeMessage</code> pada dasarnya tidak pernah digunakan oleh templat dan menjadi hal yang sia-sia karena kode tersebut tidak pernah mempengaruhi pengguna pada akhirnya.</p>\n<p>Untuk mengakomodir hal ini, beberapa programmer lebih senang melakukan unit test dengan mensimulasikan apa yang harus dilakukan pengguna akhir pada aplikasi mereka tanpa mengakses ke <em>method</em> secara langsung.</p>\n<p>Dari contoh kode sebelumnya kita akan melakukan perubahan agar <em>method</em> <code>changeMessage</code> menjadi berguna, seperti berikut:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;h1 class=&quot;message&quot;&gt;{{ msg }}&lt;/h1&gt;\n    &lt;button\n      class=&quot;btn&quot;\n      @click=&quot;changeMessage('Sebuah pesan baru')&quot;&gt;\n      Ubah pesan\n    &lt;/button&gt;\n&lt;/template&gt;\n</code></pre>\n<p>Dengan bagian <code>script</code> seperti berikut ini:</p>\n<pre><code class=\"language-javascript\">export default {\n  name: 'HelloWorld',\n  data () {\n    return {\n      msg: 'Sebuah pesan'\n    }\n  },\n  methods: {\n    changeMessage (newMessage) {\n      this.msg = newMessage\n    }\n  }\n}\n</code></pre>\n<p>Dari kode diatas, kita bisa membuatkan unit test seperti berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('berhasil mounting komponen', () =&gt; {\n    const msgExpected = 'Sebuah pesan'\n    const wrapper = shallowMount(HelloWorld)\n    expect(wrapper.find('.message')).toBe(msgExpected)\n  })\n\n  it('berhasil memanggil changeMessage melalui aksi klik', () =&gt; {\n    const msgExpected = 'Sebuah pesan'\n    const msgAfterChangeExpected = 'Sebuah pesan baru'\n    const wrapper = shallowMount(HelloWorld)\n    expect(wrapper.find('.message')).toBe(msgExpected)\n\n    // memanggil method changeMessage lewat aksi klik\n    const buttonElemen = wrapper.find('.btn')\n    buttonWrapper.trigger('click')\n\n    // mengecek perubahan setelah klik\n    expect(wrapper.find('.message')).toBe(msgAfterChangeExpected)\n  })\n})\n</code></pre>\n<p>Bisa dilihat perbedaanya dari cara kita melakukan test pada bagian sebelumnya dengan cara kita melakukan test pada bagian ini, pada bagian ini kita benar-benar mensimulasikan bagaimana tampilan dari komponen ini nantinya akan digunakan oleh pengguna.</p>\n<p>Kedua cara yang kita contohkan benar dan boleh saja dilakukan. Kita bahkan bisa mengerjakan kedua cara tersebut dalam satu berkas unit test. Pilihan terserah pada Anda masing-masing. Cara pertama tentu lebih cepat apalagi kalau mengejar <code>coverage</code>, cara kedua lebih baik dan lebih berorientasi pada pengguna tapi seringkali menghabiskan lebih banyak waktu untuk dibuat.</p>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Props-di-Komponen-Vue\">Testing Props di Komponen Vue</h2>\n<p>Sebelum melakukan test pada <em>props</em>, kita mesti mengetahui terlebih dahulu bahwa <em>props</em> adalah sebuah nilai yang dioper oleh komponen lain, nilainya berupa satu arah yang artinya tidak bisa kita ubah secara langsung dari komponen yang menerima <em>props</em>, beberapa props sudah didefinisikan tipe data maupun struktur data yang diperbolehkan. Pada unit test kita bisa menggunakan fitur <code>propsData</code> untuk melempar <em>props</em> pada komponen tanpa perlu membuat komponen induk terlebih dahulu, berikut contoh membuat unit test pada <em>props</em>:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    &lt;h1&gt;{{ msg }}&lt;/h1&gt;\n    &lt;h2&gt;{{ num }}&lt;/h2&gt;\n    &lt;h3&gt;{{ obj.name }}&lt;/h3&gt;\n    &lt;h4&gt;{{ obj.desc }}&lt;/h4&gt;\n&lt;/template&gt;\n</code></pre>\n<p>Dengan kode bagian <code>script</code> sebagai berikut:</p>\n<pre><code class=\"language-javascript\">export default {\n  name: 'HelloWorld',\n  props: {\n    msg: String,\n    num: {\n      type: Number,\n      default: 0\n    },\n    obj: {\n      type: Object,\n      default: () =&gt; ({\n        name: '',\n        desc: ''\n      })\n    },\n  }\n}\n</code></pre>\n<p>Maka kita bisa membuat unit test dari kode diatas sebagai berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('renders props.msg ketika dilempar', () =&gt; {\n    const msgProp = 'sebuah pesan'\n    const numProp = 12345\n    const objProp = {\n      name: 'sebuah nama',\n      desc: 'sebuah deskripsi'\n    }\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: {\n        msg: msgProp,\n        num: numProp,\n        obj: objProp,\n      }\n    })\n    expect(wrapper.find('h1')).toBe(msgProp)\n    expect(wrapper.find('h2')).toBe(numProp)\n    expect(wrapper.find('h3')).toBe(objProp.name)\n    expect(wrapper.find('h4')).toBe(objProp.desc)\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Computed-dan-Watcher\">Testing Computed dan Watcher</h2>\n<p>Untuk melakukan test pada <em>computed</em> dan <em>watch</em> kita perlu mengetahui apa yang sebenarnya dilakukan keduanya di dalam Vue <strong>SFC</strong>. Kita akan memahami mengenai dua hal ini lewat contoh kode berikut:</p>\n<pre><code class=\"language-javascript\">export default {\n  data () {\n    return {\n      firstName: 'Irfan',\n      lastName: 'Maulana'\n    }\n  },\n  computed: {\n    fullName () {\n      return `${this.firstName} ${this.lastName}`\n    }\n  }\n}\n</code></pre>\n<p>Kode yang sama bila kita selesaikan dengan <em>watch</em> akan menjadi:</p>\n<pre><code class=\"language-javascript\">export default {\n  data () {\n    return {\n      firstName: 'Irfan',\n      lastName: 'Maulana',\n      fullName: '',\n    }\n  },\n  watch: {\n    firstName (newValue) {\n      this.fullName = `${newValue} ${this.lastName}`\n    },\n    lastName (newValue) {\n      this.fullName = `${this.firstName} ${newValue}`\n    }\n  }\n}\n</code></pre>\n<p>Dari contoh kode diatas, kita bisa tau bahwa <em>computed</em> akan mengkalkulasikan ulang nilainya pada saat suatu variabel yang digunakan dibawah fungsi <em>computed</em> mengalami perubahan. Ciri khas dari <em>computed</em> sendiri adalah selalu mengambalikan nilai baru yang akan menjadi bagian dari <em>data</em>, meskipun begitu nilai dari <em>computed</em> tidak bisa kita ubah secara langsung. Nilainya hanya bisa diubah dengan melakukan perubahan pada variabel yang digunakan oleh <em>computed</em> tersebut. Sedangkan pada <em>watch</em> sama-sama akan dijalankan ketika terjadi perubahan pada variabel di dalamnya, hanya saja <em>watch</em> tidak akan mengembalikan nilai baru yang bisa kita gunakan.</p>\n<p>Berikut contoh kode untuk membuat unit test pada <em>computed</em>:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;h1&gt;{{ fullName }}&lt;/h1&gt;\n&lt;/template&gt;\n</code></pre>\n<p>Dengan bagian <code>script</code> berisi kode berikut:</p>\n<pre><code class=\"language-javascript\">export default {\n  data () {\n    return {\n      firstName: 'Irfan',\n      lastName: 'Maulana'\n    }\n  },\n  computed: {\n    fullName () {\n      return `${this.firstName} ${this.lastName}`\n    }\n  }\n}\n</code></pre>\n<p>Dari kode tersebut kita membuat unit test berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('computed seharusnya ter-trigger', () =&gt; {\n    const wrapper = shallowMount(HelloWorld)\n    expect(wrapper.find('h1')).toBe('Irfan Maulana')\n\n    // nilai firstName dan lastName akan kita ubah\n    wrapper.vm.firstName = 'Syamil'\n    wrapper.vm.lastName = 'Al-Khawarizmi'\n\n    // mengecek perubahan\n    expect(wrapper.find('h1')).toBe('Syamil Al-Khawarizmi')\n  })\n})\n</code></pre>\n<p>Pada kasus menggunakan <em>watch</em> bisa dilihat perubahan kodenya menjadi pada contoh kasus berikut:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;h1&gt;{{ fullName }}&lt;/h1&gt;\n&lt;/template&gt;\n</code></pre>\n<p>Dengan bagian <code>script</code> berisikan kode:</p>\n<pre><code class=\"language-javascript\">export default {\n  data () {\n    return {\n      firstName: 'Irfan',\n      lastName: 'Maulana',\n      fullName: '',\n    }\n  },\n  watch: {\n    firstName (newValue) {\n      this.fullName = `${newValue} ${this.lastName}`\n    },\n    lastName (newValue) {\n      this.fullName = `${this.firstName} ${newValue}`\n    }\n  }\n}\n</code></pre>\n<p>Dari kode tersebut kita membuat unit test berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('watch seharusnya ter-trigger', () =&gt; {\n    const wrapper = shallowMount(HelloWorld)\n    expect(wrapper.find('h1')).toBe('Irfan Maulana')\n\n    // nilai firstName dan lastName akan kita ubah\n    wrapper.vm.firstName = 'Syamil'\n    wrapper.vm.lastName = 'Al-Khawarizmi'\n\n    // mengecek perubahan\n    expect(wrapper.find('h1')).toBe('Syamil Al-Khawarizmi')\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Event-Emitter\">Testing Event Emitter</h2>\n<p>Seringkali pada sebuah komponen kita harus melakukan <code>$emit</code> terhadap <em>event</em> yang dilempar oleh komponen induknya. Masalahnya adalah ketika kita mengetest komponen anak yang seperti ini, kita sebenarnya tidak pernah tau <em>event</em> seperti apa yang akan dilempar oleh komponen induknya. Ketidakpunyaan penglihatan kita terhadap aksi sejenis ini membuat kita tidak bisa melakukan test yang bisa kita pastikan hasilnya, karenanya kita biasanya cuma akan melakukan <code>Spy</code> terhadap fungsi seperti ini. Untungnya dari <code>@vue/test-utils</code> sudah menyediakan API yang memudahkan kita melakukan ini yakni <a href=\"https://vue-test-utils.vuejs.org/api/wrapper/emitted.html\">emitted â†—ï¸</a>.</p>\n<p>Contoh menggunakan <code>emitted</code> sebagai berikut, misalkan kita memiliki kode:</p>\n<pre><code class=\"language-javascript\">export default {\n  methods: {\n    emitSomething () {\n      this.$emit('foo', 123)\n    }\n  }\n}\n</code></pre>\n<p>Maka kita bisa membuatkan unit test sebagai berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('memanggil $emit', () =&gt; {\n    const wrapper = shallowMount(HelloWorld)\n    wrapper.vm.emitSomething()\n    expect(wrapper.emitted().foo).toBeTruthy()\n    expect(wrapper.emitted('foo')).toBeTruthy()\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Perpindahan-Route\">Testing Perpindahan Route</h2>\n<p>Terkadang pada sebuah projek kita diharuskan melakukan manipulasi <em>route</em> pada sebuah seperti menggunakan <code>router.push</code>, <code>router.go</code> atau lainnya. Sebelum kita melakukan test pada kode seperti ini, kita paling tidak mesti tau apa yang terjadi ketika kita melakukan manipulasi <em>router</em> di Vue. Vue memanfaatkan pustaka tambahan yakni <strong>Vue Router</strong> untuk melakukan manipulasi <em>router</em> yang mana diurus secara resmi oleh tim yang sama dengan yang membuat Vue inti.</p>\n<p>Ada dua objek yang harus kita tau ketika menggunakan <strong>Vue Router</strong> yakni, <em>route</em> yang bisa diakses lewat <strong>SFC</strong> melalui <code>this.$route</code> dan juga <em>router</em> yang bisa diakses melalui <code>this.$router</code>. <em>Route</em> adalah representasi posisi halaman saat ini, berupa objek yang berisi <code>path</code>, <code>name</code>, <code>query</code> dan sebagainya. Sementara <em>router</em> merupakan objek yang bisa memanipulasi posisi <em>route</em> tersebut. Jadi kita akan mengakses <em>router</em> untuk mengubah <em>route</em> dan akan mengecek <em>route</em> untuk mengetahui apakah manipulasi tersebut berhasil ataukah tidak.</p>\n<p>Contoh kode berikut akan memberikan gambaran mengenai dua hal tersebut:</p>\n<pre><code class=\"language-javascript\">export default {\n  methods: {\n    changeRoute () {\n      this.$router.push('/')\n      // console.log(this.$route.path)\n      // akan mencetak nilai /\n    },\n    changeRouteFoo () {\n      this.$router.push('/foo')\n      // console.log(this.$route.path)\n      // akan mencetak nilai /foo\n    },\n    changeRouteBar () {\n      this.$router.push('/bar')\n      // console.log(this.$route.path)\n      // akan mencetak nilai /bar\n    }\n  }\n}\n</code></pre>\n<p>Dari kode diatas kita bisa membuat beberapa alternatif untuk unit test kita, antara lain sebagai berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount, createLocalVue } from '@vue/test-utils'\nimport VueRouter from 'vue-router'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\nconst localVue = createLocalVue()\nlocalVue.use(VueRouter)\n\nconst Foo = { template: '&lt;div&gt;foo&lt;/div&gt;' }\nconst Bar = { template: '&lt;div&gt;bar&lt;/div&gt;' }\nconst dummyRoutes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('mengubah $route pada komponen', () =&gt; {\n    const router = new VueRouter({\n      routes: dummyRoutes\n    })\n\n    const wrapper = shallowMount(HelloWorld, {\n      localVue,\n      router\n    })\n\n    // ubah $route ke /\n    wrapper.vm.changeRoute()\n    expect(wrapper.vm.$route.path).toBe('/')\n    // ubah $route ke /foo\n    wrapper.vm.changeRouteFoo()\n    expect(wrapper.vm.$route.path).toBe('/foo')\n    // ubah $route ke /bar\n    wrapper.vm.changeRouteBar()\n    expect(wrapper.vm.$route.path).toBe('/bar')\n  })\n})\n</code></pre>\n<p>Dari contoh kode unit test diatas, kita belajar untuk menggunakan <code>localVue</code> dari <code>@vue/test-utils</code>. API ini digunakan untuk menamabahkan plugin ke dalam unit test kita, seperti dijelaskan sebelumnya bahwa Vue Router merupakan pustaka luar yang harus digunakan lewat <code>Vue.use</code> ke dalam <em>instance</em> utama dari Vue. Maka pada unit test kita memanfaatkan <code>localVue</code> untuk melakukan hal yang sama namun dalam lingkungan unit test. Selain mengoper opsi <code>localVue</code>, kita juga diharuskan melempar opsi <em>router</em> seperti saat kita melakukan <em>instance</em>  Vue ketika menggunakan <strong>Vue Router</strong> seperti contoh potongan kode berikut:</p>\n<pre><code class=\"language-javascript\">const Foo = { template: '&lt;div&gt;foo&lt;/div&gt;' }\nconst Bar = { template: '&lt;div&gt;bar&lt;/div&gt;' }\n\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\nconst router = new VueRouter({\n  routes // short for `routes: routes`\n})\n\nconst app = new Vue({\n  router\n}).$mount('#app')\n</code></pre>\n<p>Pada contoh kode unit test yang kita buat sebelumnya kita memalsukan <code>routes</code> yang ada, pada projek Vue mungkin hal ini tidak diperlukan karena kita bisa langsung impor dari berkas <code>router.js</code> yang kita buat sebelumnya tapi pada projek Nuxt yang tidak memiliki <code>router.js</code> hal ini menjadi dibutuhkan. Namun tidak menutup kemungkinan juga kita melakukan hal seperti ini pada projek Vue, kembali pada preferensi masing-masing lebih memilih kode yang mana.</p>\n<p>Sebagai catatan, <strong>Vue Router</strong> mungkin tidak akan memberikan error ketika kita memindahkan sebuah <em>route</em> ke alamat yang tidak dikenal atau belum didefinisikan sebelumnya, namun kita bisa mengetahui apakah proses pemindahan itu berhasil atau tidak dari posisi <em>route</em> setelah pemindahan tersebut. Bila gagal, maka posisi <em>route</em> akan tetap sama seperti sebelumnya atau dalam kata lain tidak terjadi apa-apa pada objek <em>route</em> tersebut.</p>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Mounting-Route\">Testing Mounting Route</h2>\n<p>Pada beberapa kasus kalian akan memanggil <code>this.$route</code> pada siklus hidup mounted atau pada computed yang mana juga akan dikalkulasi secepatnya setelah komponen tersebut dibuat. Dengan contoh kasus seperti ini, cara yang kita gunakan seperti diatas bisa jadi akan memberikan galat pada saat melakukan render di kode unit test kita.</p>\n<p>Untuk menyelesaikan masalah ini, kita bisa memanfaatkan fitur <code>mock</code> dari Vue Test util dengan contoh seperti kode berikut:</p>\n<pre><code class=\"language-javascript\">const $route = {\n  path: 'http://www.example-path.com',\n  params: '',\n  query: {},\n  fullPath: ''\n  // see https://router.vuejs.org/api/#route-object-properties for complete properties\n}\nconst wrapper = shallowMount(Component, {\n  mocks: {\n    $route\n  }\n})\nexpect(wrapper.vm.$route.path).toBe($route.path)\n</code></pre>\n<p>Hal yang perlu diperhatikan adalah bahwa kita tidak perlu lagi melempar route <em>bohongan</em> pada saat membuat Vue Instance seperti yang sebelumnya kita kerjakan, jadi bisa cukup dengan kode berikut:</p>\n<pre><code class=\"language-javascript\">const wrapper = shallowMount(HelloWorld, {\n  localVue,\n  // router // -- bagian ini tidak diperlukan lagi\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Vuex\">Testing Vuex</h2>\n<p><a href=\"https://vuex.vuejs.org/\">Vuex â†—ï¸</a> merupakan salah satu pustaka yang sering sekali kita gunakan dalam suatu projek. Vuex menjadi satu-satunya pilihan yang paling mumpuni sebagai manajemen state pada Vue untuk saat ini. Berikut beberapa hal yang akan sering kita jumpai saat melakukan test pada aplikasi Vue yang menggunakan Vuex di dalamnya:</p>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h3 id=\"Testing-Getters\">Testing Getters</h3>\n<p><em>Getters</em> biasanya digunakan ketika kita ingin melakukan manipulasi pada state sebelum digunakan di sebuah komponen tanpa mengubah nilai asli dari state tersebut.</p>\n<p>Contoh kode <em>getters</em> seperti berikut:</p>\n<pre><code class=\"language-javascript\">export default {\n  state: {\n    messages: []\n  },\n  getters: {\n    unreadMessages(state) {\n      return state.messages.filter(item =&gt; item.read === 0)\n    },\n    readMessages(state) {\n      return state.messages.filter(item =&gt; item.read === 1)\n    }\n  },\n  mutations: {\n    setMessageList: (state, data) =&gt; {\n      state.messages = data\n    }\n  }\n}\n</code></pre>\n<p>Dari kode diatas kita mempunyai dua <em>getters</em> yakni <code>unreadMessages</code> dan <code>readMessages</code>. Keduanya digunakan untuk mengambil spesifik nilai dari sebuah daftar di state <code>messages</code>. Getters bisa di test seperti kode JavaScript biasa tanpa perlu melakukan <em>instance</em> Vuex Store terlebih dahulu, namun bisa juga kita test lewat <em>instance</em> Vuex Store bila memang dibutuhkan.</p>\n<p>Berikut contoh unit test untuk kode <em>getters</em> diatas:</p>\n<pre><code class=\"language-javascript\">import store from '@/store/messages'\n\nconst messages = [{\n  id: 'pesan-1',\n  text: 'sebuah pesan',\n  read: 0\n}, {\n  id: 'pesan-2',\n  text: 'sebuah pesan 2',\n  read: 1\n}, {\n  id: 'pesan-3',\n  text: 'sebuah pesan 3',\n  read: 1\n}]\n\ndescribe('Vuex Store: Messages', () =&gt; {\n  it('unreadMessages harus mengembalikan nilai yang benar', () =&gt; {\n    const result = store.getters.unreadMessages({\n      messages\n    })\n    const expectedResult = [{\n      id: 'pesan-1',\n      text: 'sebuah pesan',\n      read: 0\n    }]\n\n    expect(result).toEqual(expectedResult)\n  })\n\n  it('readMessages harus mengembalikan nilai yang benar', () =&gt; {\n    const result = store.getters.readMessages({\n      messages\n    })\n    const expectedResult = [{\n      id: 'pesan-2',\n      text: 'sebuah pesan 2',\n      read: 1\n    }, {\n      id: 'pesan-3',\n      text: 'sebuah pesan 3',\n      read: 1\n    }]\n\n    expect(result).toEqual(expectedResult)\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h3 id=\"Testing-Mutations\">Testing Mutations</h3>\n<p><em>Mutations</em> digunakan untuk mengubah nilai state, seperti kita tau bersama bahwa di Vuex terlarang untuk mengubah nilai state secara langsung. Semua perubahan state diharuskan untuk lewat <em>mutations</em>.</p>\n<p>Contoh kode <em>mutations</em> sebagai berikut:</p>\n<pre><code class=\"language-javascript\">export default {\n  state: {\n    messages: []\n  },\n  mutations: {\n    setMessageList: (state, data) =&gt; {\n      state.messages = data\n    }\n  }\n}\n</code></pre>\n<p>Dari kode diatas kita bisa membuatkan unit test seperti berikut:</p>\n<pre><code class=\"language-javascript\">import store from '@/store/messages'\n\nconst messages = [{\n  id: 'pesan-1',\n  text: 'sebuah pesan',\n  read: 0\n}, {\n  id: 'pesan-2',\n  text: 'sebuah pesan 2',\n  read: 1\n}, {\n  id: 'pesan-3',\n  text: 'sebuah pesan 3',\n  read: 1\n}]\n\ndescribe('Vuex Store: Messages', () =&gt; {\n  it('setMessageList harus mengubah nilai state messages', () =&gt; {\n    let dummyState = {\n      messages: []\n    }\n    store.mutations.setMessageList(dummyState, messages)\n    expect(dummyState.messages).toEqual(messages)\n  })\n})\n</code></pre>\n<p>Kita bisa juga melakukan test dengan menggunakan <em>instance</em> Vuex Store untuk mengakses <em>mutations</em> seperti berikut:</p>\n<pre><code class=\"language-javascript\">import Vuex from 'vuex';\nimport store from '@/store/messages'\n\nconst $storeInstance = new Vuex.Store(store)\n\nconst messages = [{\n  id: 'pesan-1',\n  text: 'sebuah pesan',\n  read: 0\n}, {\n  id: 'pesan-2',\n  text: 'sebuah pesan 2',\n  read: 1\n}, {\n  id: 'pesan-3',\n  text: 'sebuah pesan 3',\n  read: 1\n}]\n\ndescribe('Vuex Store: Messages', () =&gt; {\n  it('setMessageList harus mengubah nilai state messages', () =&gt; {\n    // memanggil mutations lewat Vuex Instance\n    $storeInstance.commit('setMessageList', messages)\n    // mengecek perubahan state\n    expect($storeInstance.state.messages).toEqual(messages)\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h3 id=\"Testing-Actions\">Testing Actions</h3>\n<p><em>Actions</em> digunakan untuk mengeksekusi berbagai fungsi yang tidak berjalan sinkron (<em>asynchronous</em>), berikut contoh kode Actions:</p>\n<pre><code class=\"language-javascript\">import axios from 'axios'\n\nexport default {\n  state: {\n    messages: []\n  },\n  mutations: {\n    setMessageList: (state, data) =&gt; {\n      state.messages = data\n    }\n  },\n  actions: {\n    async fetchMessages({ commit }, { username }) {\n      const response = await axios.get(&quot;/api/messages&quot;, {\n        username\n      })\n      commit('setMessageList', response.data)\n    }\n  }\n}\n</code></pre>\n<p>Dari kode diatas kita bisa membuatkan unit test sebagai berikut:</p>\n<pre><code class=\"language-javascript\">import axios from 'axios'\nimport store from '@/store/messages'\n\nconst messages = [{\n  id: 'pesan-1',\n  text: 'sebuah pesan',\n  read: 0\n}, {\n  id: 'pesan-2',\n  text: 'sebuah pesan 2',\n  read: 1\n}, {\n  id: 'pesan-3',\n  text: 'sebuah pesan 3',\n  read: 1\n}]\n\ndescribe('Vuex Store: Messages', () =&gt; {\n  it('fetchMessages harus mendapatkan semua data messages', () =&gt; {\n    const commit = jest.fn()\n    const mockFetchPromise = Promise.resolve({\n      data: messages,\n    })\n    axios.get = jest.fn().mockResolvedValue(mockFetchPromise)\n\n    store.actions.fetchMessages({ commit }, { username: 'dummy-username' })\n    expect(commit).toHaveBeenCalledWith('setMessageList', messages)\n  })\n})\n</code></pre>\n<p>Dengan cara diatas, kita tidak bisa mengecek perubahan <em>state</em> karena fungsi <code>commit</code> sudah di-<em>mock</em> sehingga tidak lagi memanggil fungsi yang sesungguhnya. Untuk mengatasi kekurangan diatas kita bisa meng-<em>instance</em> Vuex Store agar fungsi commit yang sesungguhnya bisa dipakai di unit test. Berikut contoh kodenya:</p>\n<pre><code class=\"language-javascript\">import Vuex from 'vuex'\nimport axios from 'axios'\nimport store from '@/store/messages'\n\nconst $storeInstance = new Vuex.Store(store)\n\nconst messages = [{\n  id: 'pesan-1',\n  text: 'sebuah pesan',\n  read: 0\n}, {\n  id: 'pesan-2',\n  text: 'sebuah pesan 2',\n  read: 1\n}, {\n  id: 'pesan-3',\n  text: 'sebuah pesan 3',\n  read: 1\n}]\n\ndescribe('Vuex Store: Messages', () =&gt; {\n  it('fetchMessages harus mendapatkan semua data messages', () =&gt; {\n    const mockFetchPromise = Promise.resolve({\n      data: messages,\n    })\n    axios.get = jest.fn().mockResolvedValueOnce(mockFetchPromise)\n    // mengeksekusi actions lewat Vuex Instance\n    $storeInstance.dispatch('fetchMessages', { username: 'dummy-username' })\n    // mengecek perubahan state\n    expect($storeInstance.state.messages).toEqual(messages)\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h3 id=\"Testing-Vuex-di-Komponen\">Testing Vuex di Komponen</h3>\n<p>Bila sebelumnya kita melakukan test langsung pada berkas Vuex itu sendiri, berikutnya kita akan memberikan contoh ketika kita menggunakan Vuex di komponen. Pada dasarnya sama saja, kita hanya perlu melakukan <em>instance</em> Vuex Store agar bisa menggunakan berbagai fitur Vuex di komponen. Bedanya hanya kita harus menambahkan <code>localVue</code> dari <code>@vue/test-utils</code> untuk memasangkan Vuex ke dalam komponen yang akan kita test. Berikut contoh kodenya:</p>\n<p>Misalkan kita memiliki berkas Vuex seperti berikut:</p>\n<pre><code class=\"language-javascript\">import axios from 'axios'\n\nexport default {\n  state: {\n    messages: []\n  },\n  mutations: {\n    setMessageList: (state, data) =&gt; {\n      state.messages = data\n    }\n  },\n  actions: {\n    async fetchMessages({ commit }, { username }) {\n      const response = await axios.get(&quot;/api/messages&quot;, {\n        username\n      })\n      commit('setMessageList', response.data)\n    }\n  }\n}\n</code></pre>\n<p>Dan akan digunakan di komponen <code>HelloWorld.vue</code> pada bagian templat seperti berikut:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Contoh Vuex di Komponen&lt;/h1&gt;\n    &lt;ul\n      v-for=&quot;message in messages&quot;\n      :key=&quot;message.id&quot;&gt;\n      {{ message.text }}\n    &lt;/ul&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>Sedangkan pada bagian <code>script</code> berisi kode berikut:</p>\n<pre><code class=\"language-javascript\">import { mapState, mapActions } from &quot;vuex&quot;\n\nexport default {\n  data () {\n    return {\n      username: 'dummy-username'\n    }\n  },\n  computed: {\n    ...mapState([\n      'messages'\n    ])\n  },\n  methods: {\n    ...mapState([\n      'fetchMessages'\n    ]),\n    fireFetchMessage() {\n      this.fetchMessages({\n        username: this.username\n      })\n    }\n  }\n}\n</code></pre>\n<p>Dari kode di atas kita bisa membuat unit test seperti berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount, localVue } from '@vue/test-utils'\nimport Vuex from 'vuex'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\nconst localVue = createLocalVue()\nlocalVue.use(Vuex)\n\nconst mockFetchMessages = jest.fn()\nconst store = new Vuex.Store({\n  state: {\n    messages: []\n  },\n  actions: {\n    fetchMessages: mockFetchMessages\n  }\n})\n\ndescribe('HelloWorld.vue', () =&gt; {\n  // reset semua pemalsuan (mock) setiap selesai test\n  afterEach(() =&gt; {\n    jest.clearAllMocks()\n  })\n\n  it('memanggil methods fireFetchMessage', async (done) =&gt; {\n    // mengoper localVue dan store\n    const wrapper = shallowMount(HelloWorld, {\n      store,\n      localVue\n    })\n    await wrapper.vm.fireFetchMessage()\n\n    expect(mockFetchMessages).toHaveBeenCalledTimes(1)\n    expect(mockFetchMessages).toHaveBeenCalledWith({\n      username: 'dummy-username'\n    })\n    done()\n  })\n})\n</code></pre>\n<p>Pada unit test di atas saya memilih untuk melakukan <em>mock</em> pada actions <code>fetchMessages</code> yang akan ikut terpanggil ketika kita memanggil method <code>fireFetchMessage</code>. Tujuannya agar tidak perlu berulang melakukan <em>mock</em> pada pemanggilan Rest API yang sebenarnya sudah dikerjakan ketika membuat unit test untuk file <em>store</em> itu sendiri. Sebenarnya kita bisa juga memilih untuk memanggil store tanpa melakukan <em>mock</em> sehingga kodenya akan memanggil store yang sesungguhnya. berikut contoh kodenya:</p>\n<pre><code class=\"language-javascript\">import { shallowMount, localVue } from '@vue/test-utils'\nimport Vuex from 'vuex'\nimport axios from 'axios'\nimport storeMessages from '@/store/messages'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\nconst localVue = createLocalVue()\nlocalVue.use(Vuex)\n\nconst store =  new Vuex.Store(storeMessages)\n\nconst messages = [{\n  id: 'pesan-1',\n  text: 'sebuah pesan',\n  read: 0\n}, {\n  id: 'pesan-2',\n  text: 'sebuah pesan 2',\n  read: 1\n}, {\n  id: 'pesan-3',\n  text: 'sebuah pesan 3',\n  read: 1\n}]\n\ndescribe('HelloWorld.vue', () =&gt; {\n  // reset semua pemalsuan (mock) setiap selesai test\n  afterEach(() =&gt; {\n    jest.clearAllMocks()\n  })\n\n  it('memanggil methods fireFetchMessage', async (done) =&gt; {\n    const mockFetchPromise = Promise.resolve({\n      data: messages,\n    })\n    axios.get = jest.fn().mockResolvedValueOnce(mockFetchPromise)\n    // mengoper localVue dan store\n    const wrapper = shallowMount(HelloWorld, {\n      store,\n      localVue\n    })\n    await wrapper.vm.fireFetchMessage()\n    process.nextTick(() =&gt; {\n      expect(wrapper.vm.messages).toEqual(messages)\n      done()\n    })\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Vuex-dengan-Modules\">Testing Vuex dengan Modules</h2>\n<p>Pada projek Vue dengan skala besar dan kompleks seringkali kita melakukan scoping pada kode Vuex dengan menggunakan fitur <a href=\"https://vuex.vuejs.org/guide/modules.html\">Vuex Modules â†—ï¸</a>. Ketika kita menggunakan fitur Modules ini, maka cara kita memalsukan Vuex pada unit testing pun menjadi berbeda dengan cara kita ketika tidak menggunakan Module.</p>\n<p>Katakanlah kita membuat Vuex Module dengan cara berikut:</p>\n<pre><code class=\"language-javascript\">const moduleA = {\n  namespace: true,\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  namespace: true,\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n</code></pre>\n<p>Maka pada unit test kita bisa memalsukan dengan cara seperti berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount, localVue } from '@vue/test-utils'\nimport Vuex from 'vuex'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\nconst localVue = createLocalVue()\nlocalVue.use(Vuex)\n\nconst moduleA = {\n  namespace: true,\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  namespace: true,\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  },\n  state: { ... }, //  state di luar modules\n  mutations: { ... }, //  mutations di luar modules\n  actions: { ... } //  actions di luar modules\n})\n\ndescribe('HelloWorld.vue', () =&gt; {\n  it('memanggil state modules dengan namespace', (done) =&gt; {\n    // mengoper localVue dan store dalam shallowRender\n    const wrapper = shallowMount(HelloWorld, {\n      store,\n      localVue\n    })\n    done()\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-dengan-Vue-i18n\">Testing dengan Vue-i18n</h2>\n<p><a href=\"http://kazupon.github.io/vue-i18n/\">Vue-i18n â†—ï¸</a> menjadi salah satu pilihan terbaik bila kita ingin mendukung beberapa bahasa dalam sebuah projek Vue kita. Dengan Menggunakan Vue-i18n akan membuat cara kita melakukan unit test sedikit berbeda dibandingkan ketika tidak menggunakannya.</p>\n<p>Contoh kode tamplat ketika menggunakan Vue-i18n adalah seperti berikut:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=&quot;hello&quot;&gt;\n    {{ $t(&quot;message&quot;) }}\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>Cara paling gampang melakukan test ketika melakukan test dengan Vue-i18n adalah dengan memalsukan fungsi <code>$t</code> yang biasa digunakan untuk mengambil suatu kata dari penyimpanan bahasa yang kita kerjakan.</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe(&quot;HelloWorld&quot;, () =&gt; {\n  it(&quot;renders successfully with i18n&quot;, () =&gt; {\n    const wrapper = shallowMount(HelloWorld, {\n      mocks: {\n        $t: (msg) =&gt; msg\n      }\n    })\n  })\n})\n</code></pre>\n<p>Bisa juga kita membuatnya menjadi konfigurasi global dengan menambahkan konfigurasi pada <code>jest.config.js</code> seperti:</p>\n<pre><code class=\"language-javascript\">// untuk jest v24x\nsetupFilesAfterEnv: ['&lt;rootDir&gt;/test/setup-test.js'],\n// `setupFiles` atau `setupTestFrameworkScriptFile` untuk jest 23\n</code></pre>\n<p>Pada file <code>setup-test.js</code>, kita bisa menambahkan <code>config</code> seperti kode berikut:</p>\n<pre><code class=\"language-javascript\">import { config } from '@vue/test-utils'\nimport langEN from '@/locales/en'\n\nconst defaultLocale = 'en'\n\nconfig.mocks['$t'] = (msg) =&gt; langEN[defaultLocale][msg]\n</code></pre>\n<p>Kedua cara ini sebenarnya bukanlah cara yang sering saya gunakan, saya lebih senang memanfaastkan <code>localVue</code> untuk memasang i18n ke dalam unit test. Berikut contoh kodenya:</p>\n<pre><code class=\"language-javascript\">import { shallowMount, localVue } from '@vue/test-utils'\nimport VueI18n from 'vue-i18n'\nimport langEN from '@/locales/en'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\nlocalVue.use(VueI18n)\n\nconst i18n = new VueI18n({\n  locale: 'en', // set locale\n  messages: {\n    en: langEN\n  }\n})\n\ndescribe(&quot;HelloWorld&quot;, () =&gt; {\n  it(&quot;renders successfully with i18n&quot;, () =&gt; {\n    const wrapper = shallowMount(HelloWorld, {\n      i18n,\n      localVue\n    })\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Testing-Pemanggilan-Rest-API\">Testing Pemanggilan Rest API</h2>\n<p>Memanggil sebuah Rest API menjadi tulang punggung yang banyak digunakan saat ini sebagai media komunikasi frontend-backend. Semakin kompleks aplikasi biasanya semakin banyak pula pemanggilan ini tersebar di berbagai tempat pada projek kita.</p>\n<p>Secara bawaan, berbagai peramban teranyar sudah mendukung Fetch API sebagai alat untuk melakukan komunikasi lewat Rest API. Namun masih populernya pustaka seperti Axios membuat kita juga perlu memberikan contoh bagaimana melakukan test pada projek yang memilih menggunakan Axios untuk melakukan komunikasi dengan Rest API.</p>\n<p>Beberapa hal yang mesti kalian tau mengenai Fetch API dan pustaka Axios berkaitan dengan unit test yang akan dibuat nantinya antara lain:</p>\n<ul>\n<li>Fetch API akan mengembalikan dua level <code>Promise</code> yang bersarang, kalian perlu memanggil <code>response.json()</code> untuk mendapatkan Promise yang kedua, barulah di dalam Promise kedua ini kalian bisa mendapati nilai yang diinginkan.</li>\n<li>Fetch API merupakan API bawaan dari peramban, bisa diakses lewat objek <code>window</code> yang direfreksikan lewat objek <code>global</code> di dalam Jest.</li>\n<li>Menggunakan Axios kita tidak perlu menggunakan Promise dua kali.</li>\n<li>Response dari Axios terletak di properti <em>data</em> dari objek <code>response</code>.</li>\n<li>Dalam unit test sebisa mungkin kita tidak melakukan pemanggilan Rest API yang sesungguhnya, kita cukup melakukan simulasi terjadinya pemanggilan Rest API.</li>\n</ul>\n<p>Berikut contoh kode ketika kita melakukan pemanggilan Rest API menggunakan Fetch API:</p>\n<pre><code class=\"language-javascript\">const URL = 'https://ghibliapi.herokuapp.com/films/'\n\nexport default {\n  data () {\n    return {\n      dataResponse: []\n    }\n  },\n  methods: {\n    async fetchData () {\n      try {\n        const response = await fetch(URL)\n        const data = await response.json()\n        this.dataResponse = data\n      } catch (error) {\n        this.dataResponse = []\n      }\n    }\n  }\n}\n</code></pre>\n<p>Dari kode diatas, kita bisa membuatkan unit test seperti berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  // reset semua pemalsuan (mock) setiap selesai test\n  afterEach(() =&gt; {\n    jest.clearAllMocks()\n  })\n\n  it('memanggil Rest API dengan Fetch API', async (done) =&gt; {\n    const mockSuccessResponse = [\n      'a', 'b', 'c'\n    ];\n    const mockFetchPromise = Promise.resolve({\n      json: () =&gt; Promise.resolve(mockSuccessResponse),\n    });\n    // memalsukan fungsi fetch API\n    // selalu mengembalikan nilai sesuai yang diinginkan\n    global.fetch = jest.fn().mockResolvedValue(mockFetchPromise)\n\n    const wrapper = shallowMount(HelloWorld)\n    await wrapper.vm.fetchData()\n\n    // memastikan fungsi fetch dipanggil sekali\n    expect(global.fetch).toHaveBeenCalledTimes(1)\n    // memastikan fungsi dipanggil dengan URL yang benar\n    expect(global.fetch).toHaveBeenCalledWith('https://ghibliapi.herokuapp.com/films/')\n    expect(wrapper.vm.dataResponse).toEqual(mockSuccessResponse)\n    done()\n  })\n})\n</code></pre>\n<p>Sedangkan kode berikut ini adalah contoh kode untuk melakukan pemanggilan Rest API menggunakan pustaka Axios:</p>\n<pre><code class=\"language-javascript\">import axios from 'axios'\nconst URL = 'https://ghibliapi.herokuapp.com/films/'\n\nexport default {\n  data () {\n    return {\n      dataResponse: []\n    }\n  },\n  methods: {\n    async fetchDataAxios () {\n      try {\n        const response = await axios.get(URL)\n        this.dataResponse = response.data\n      } catch (error) {\n        this.dataResponse = []\n      }\n    }\n  }\n}\n</code></pre>\n<p>Dengan kode diatas kita bisa membuatkan unit test sebagai berikut:</p>\n<pre><code class=\"language-javascript\">import { shallowMount } from '@vue/test-utils'\nimport axios from 'axios'\nimport HelloWorld from '@/components/HelloWorld.vue'\n\ndescribe('HelloWorld.vue', () =&gt; {\n  // reset semua pemalsuan (mock) setiap selesai test\n  afterEach(() =&gt; {\n    jest.clearAllMocks()\n  })\n\n  it('memanggil Rest API dengan Axios', async (done) =&gt; {\n    const mockSuccessResponse = [\n      'a', 'b', 'c'\n    ];\n    const mockFetchPromise = Promise.resolve({\n      data: mockSuccessResponse,\n    });\n    // memalsukan fungsi fetch API\n    // selalu mengembalikan nilai sesuai yang diinginkan\n    axios.get = jest.fn().mockResolvedValue(mockFetchPromise)\n\n    const wrapper = shallowMount(HelloWorld)\n    await wrapper.vm.fetchDataAxios()\n\n    // memastikan fungsi fetch dipanggil sekali\n    expect(axios.get).toHaveBeenCalledTimes(1)\n    // memastikan fungsi dipanggil dengan URL yang benar\n    expect(axios.get).toHaveBeenCalledWith('https://ghibliapi.herokuapp.com/films/')\n    expect(wrapper.vm.dataResponse).toEqual(mockSuccessResponse)\n    done()\n  })\n})\n</code></pre>\n<p><a href=\"#navigasi\">ğŸ”¼ Kembali ke navigasi</a></p>\n<h2 id=\"Referensi\">Referensi</h2>\n<ol>\n<li><a href=\"https://www.guru99.com/unit-testing-guide.html\">https://www.guru99.com/unit-testing-guide.html â†—ï¸</a></li>\n<li><a href=\"https://howtodoinjava.com/best-practices/first-principles-for-good-tests/\">https://howtodoinjava.com/best-practices/first-principles-for-good-tests/ â†—ï¸</a></li>\n<li><a href=\"https://lmiller1990.github.io/vue-testing-handbook/\">https://lmiller1990.github.io/vue-testing-handbook/ â†—ï¸</a></li>\n<li><a href=\"https://vue-test-utils.vuejs.org/\">https://vue-test-utils.vuejs.org/ â†—ï¸</a></li>\n</ol>\n"}}}]);